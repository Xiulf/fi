module Fmt

import Fmt.Arg (FmtArg)

extern "C" puts: fn (string: [*:0]u8) -> i32;
extern "C" write: fn (stream: i32, buf: [*]u8, count: usize) -> isize;

fn print_args(argc: i32, argv: [*][*:0]u8)
    var i = 0;

    while i < argc.(usize)
        puts(argv[i]);
        i += 1;
    end   
end

fn print_fmt(fmt: str, args: []FmtArg)
    write_fmt(0, fmt, args)
end

fn write_fmt(stream: i32, fmt: str, args: []FmtArg)
    var i = 0;
    var a = 0;

    while i < fmt.len
        var ch = fmt[i];

        if ch == '%'.(u8)
            var arg = args[a];

            (arg.f)(arg.val, stream);
            a += 1;
        else
            write(stream, (&ch).([*]u8), 1);
        end

        i += 1;
    end
end

module Fmt.Arg (
    FmtArg,
    str, bool,
    u8, usize
)

extern "C" write: fn (stream: i32, buf: [*]u8, count: usize) -> isize;

struct FmtArg
    val: *()
    f: fn(val: *(), stream: i32) -> ()
end

fn str(s: *str) -> FmtArg
    FmtArg(s.(*()), fmt_str)
end

fn bool(b: *bool) -> FmtArg
    FmtArg(b.(*()), fmt_bool)
end

fn u8(v: *u8) -> FmtArg
    FmtArg(v.(*()), fmt_u8)
end

fn usize(v: *usize) -> FmtArg
    FmtArg(v.(*()), fmt_usize)
end

fn fmt_str(val: *(), stream: i32)
    var val = val.(*str);
    
    write(stream, val.ptr, val.len);
end

fn fmt_bool(val: *(), stream: i32)
    var val = val.(*bool).*;
    var true = "true";
    var false = "false";

    if val
        write(stream, true.ptr, true.len);
    else
        write(stream, false.ptr, false.len);
    end
end

fn fmt_u8(val: *(), stream: i32)
    fn rec(val: u8, stream: i32)
        if val >= 10
            rec(val / 10, stream);
        end

        var ch = '0' + (val % 10).(u32)

        write(stream, (&ch).([*]u8), 1);
    end

    rec(val.(*u8).*, stream)
end

fn fmt_usize(val: *(), stream: i32)
    fn rec(val: usize, stream: i32)
        if val >= 10
            rec(val / 10, stream);
        end

        var ch = '0' + (val % 10).(u32)

        write(stream, (&ch).([*]u8), 1);
    end

    rec(val.(*usize).*, stream)
end
