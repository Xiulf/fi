module main =

import core
import core/io


fn main =
    a <- "test"
    println a

fn test = fn a b -> "test"

fn fsdfdsfs = 0 :: Str

type Option t =
    | None
    | Some t

type OptionTry t e = Option t

member OptionTry Infallible of Try =
    fn from_output o = Some o

; member Option of Functor =
;     fn map f a = case a of
;         None -> None
;         Some a -> Some (f a)
; 
; member Option of Apply =
;     fn apply f a = case f of
;         None -> None
;         Some f -> case a of
;             None -> None
;             Some a -> Some (f a)
; 
; member Option of Applicative =
;     fn pure a = Some a
; 
; member Option of Bind =
;     fn bind m f = case m of
;         None -> None
;         Some a -> f a
; 
; member Option of Monad
; 
; 
; class Functor f =
;     fn map :: (a -> b), f a -> f b
; 
; class Apply f where Functor f =
;     fn apply :: f (a -> b), f a -> f b
; 
; class Applicative f where Apply f =
;     fn pure :: a -> f a
; 
; class Bind m where Apply m =
;     fn bind :: m a, (a -> m b) -> m b
; 
; class Monad m where Bind m, Applicative m
; 
; 
; infixl 4 map as (<$>)
; infixl 4 apply as (<*>)
; infixl 1 bind as (>>=)

foreign type Infallible :: core/Type

type ControlFlow b n =
    | Next n
    | Break b

class Try self residual where FromResidual self residual =
    fn from_output :: output -> self output residual
    fn branch :: self output residual -> ControlFlow residual output

class FromResidual self residual =
    fn from_residual :: residual -> self output residual
