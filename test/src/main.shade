module main =

import core
import core/io


fn main =
    let a = case branch (Ok "test") of
        Next x -> x
        Break e -> return from_residual e
    pure (println a)


type Option t =
    | None
    | Some t

type Result e t =
    | Err e
    | Ok t


class Try self val err where FromResidual (self val) err =
    fn pure :: val -> self val
    fn branch :: self val -> ControlFlow err val

class FromResidual self err =
    fn from_residual :: err -> self

type ControlFlow b n =
    | Break b
    | Next n


member Option t () of Try =
    fn pure x = Some x

    fn branch self = case self of
        Some x -> Next x
        None -> Break ()

member (Option t) () of FromResidual =
    fn from_residual _ = None


member (Result e) t e of Try =
    fn pure x = Ok x

    fn branch self = case self of
        Ok x -> Next x
        Err e -> Break e

member (Result e t) e of FromResidual =
    fn from_residual e = Err e
