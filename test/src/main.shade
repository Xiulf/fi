module main =

import core
import core/io


fn main =
    let a = case branch (Ok "test") of
        Next x -> x
        Break e -> return from_residual e
    pure (println a)


type Option t =
    | None
    | Some t

type Result e t =
    | Err e
    | Ok t


class Try self err where FromResidual self err =
    fn pure :: val -> self val
    fn branch :: self val -> ControlFlow err val

class FromResidual self err =
    fn from_residual :: err -> self

type ControlFlow b n =
    | Break b
    | Next n


member Option () of Try =
    fn pure x = Some x

    fn branch self = case self of
        Some x -> Next x
        None -> Break ()

; member Option () of FromResidual =
;     fn from_residual _ = None


member (Result e) e of Try =
    fn pure x = Ok x

    fn branch self = case self of
        Ok x -> Next x
        Err e -> Break e

; member (Result e) e of FromResidual =
;     fn from_residual e = Err e
