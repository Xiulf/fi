module Main (main) =

import Core
import Intrinsics


module C =
    import Core

    foreign malloc :: Uptr -> Ptr ()
    foreign free :: Ptr () -> ()

    foreign printf :: Ptr Int8, .. -> Int32

    @link_name = "write"
    @cfg(windows)
    foreign write :: Int32, Ptr Int8, Uptr -> Int32


malloc () :: Ptr a = size_of (Proxy :: Proxy a) |> C.malloc |> transmute
free p = C.free <| transmute p


@boxed
type List t =
    | Nil
    | Cons t (List t)

infixr 6 (:) = Cons

len list =
    match list with
    | Nil -> 0
    | Cons x xs -> 1 + (len xs)

trait Iterable t a =
    for_each :: t, (a -> ()) -> ()

trait Foldable t a =
    fold :: t, acc, (acc, a -> acc) -> acc

impl Iterable (List a) a =
    for_each list f =
        match list with
        | x:xs ->
            f x
            for_each xs f
        | _ -> ()

impl Foldable (List a) a =
    fold list init f =
        match list with
        | x:xs ->
            acc = f init x
            fold xs acc f
        | _ -> init


@main
main () =
    printf "test\n" "abc\n" :: ()
    list = 4:5:6:Nil
    fold list 0 fn a b -> a + b


printf (s :: Str) :: r where PrintfType r =
    printf' s Nil

trait PrintfType t =
    printf' :: Str, List Str -> t

impl PrintfType () =
    printf' f args =
        match args with
        | x:xs ->
            Stdout .fmt x
            printf' f xs
        | _ -> Stdout .fmt f

// impl PrintfType () =
//     printf' f args =
//         for_each args fn a -> Stdout .fmt a
//         Stdout .fmt f

impl PrintfType ({Pair Str (List Str)} Str -> r) where PrintfType r =
    printf' f args = fn x ->
        printf' f (x:args)

// print f = Stdout .fmt f
// println f =
//     Stdout .fmt f
//     Stdout .fmt '\n'

// eprint f = Stderr .fmt f
// eprintln f =
//     Stderr .fmt f
//     Stderr .fmt '\n'


// printf (s :: Str) :: r where PrintfType r =
//     printf' s ()

// trait PrintfType t =
//     printf' :: Str, Slice Str -> t

// impl PrintfType () =
//     printf' fmt args = ()

// impl PrintfType ({Pair Str (Slice Str)} a -> r) where Format a, PrintfType r =
//     printf' fmt args = fn x ->
//         printf' fmt args


trait Format f =
    fmt :: w, f -> () where Write w

impl Format Str =
    fmt w s =
        _ = s.transmute |> write w

impl Format Char =
    fmt w c =
        ptr = addr_of c .transmute :: Ptr Int8
        slice = (ptr, (1 :: Uptr)) .transmute
        _ = write w slice


trait Write w =
    write :: w, Slice Int8 -> Int32

type Stdout = | Stdout
type Stderr = | Stderr

impl Write Stdout =
    write _ slice =
        ptr, len = slice.transmute
        C.write 1 ptr len

impl Write Stderr =
    write _ slice =
        ptr, len = slice.transmute
        C.write 2 ptr len
