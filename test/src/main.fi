module Test =

import Core
import Socket (Socket, listen, accept, receive, send, close)

@main
main :: ExitCode
main =
    let socket = case Socket:new_ipv4 (LibC:NetAddr 127 0 0 1) 8080 of
        Ok socket -> socket
        Error e -> do
            println e
            return ExitCode -1

    case socket .listen 1 of
        Ok _ -> ()
        Error e -> do
            println e
            return ExitCode -1

    println "listening for incoming connections"
    let client = case socket .accept of
        Ok client -> client
        Error e -> do
            println e
            return ExitCode -1
    
    println "client connected"
    let buffer = Data:Array:zeroed :: Array 1000 Byte
    let slice = buffer # (Data:Range 0 1000)

    let received = case client .receive slice of
        Ok n -> n
        Error e -> do
            println e
            return ExitCode -1

    case client .send (slice # (Data:Range 0 received)) of
        Ok _ -> ()
        Error e -> do
            println e
            return ExitCode -1

    client .close
    socket .close
    ExitCode 0


println :: Str -> ()
println s =
    let ptr, _ = Intrinsics:unsafe (Intrinsics:transmute s) :: _, Uint
    LibC:puts ptr
    ()


module TcpListener =
    import Core
    import Socket (Socket)
    
    type TcpListener = | TcpListener Socket

    bind :: LibC:NetAddr -> Uint16 -> Result Str TcpListener
    bind addr port =
        case Socket:new_ipv4 addr port of
            Ok socket -> Ok $ TcpListener socket
            Error err -> Error err

    close :: TcpListener -> ()
    close (TcpListener socket) = Socket:close socket


module Socket (module Socket, module C) =
    import Core
    import LibC (NetAddr)
    import LibC (NetAddr) as C
    import Intrinsics (addr_of)
    
    type Socket =
        | Socket LibC:C_Int LibC:SockAddr

    new_ipv4 :: NetAddr -> Uint16 -> Result Str Socket
    new_ipv4 addr port =
        let desc = LibC:socket LibC:AF_INET LibC:SOCK_STREAM 0
        if desc < 0 then return Error "error while creating socket"

        let family = Intrinsics:iconvert LibC:AF_INET
        let port = Data:Int:to_be port
        let addr = LibC:SockAddr family port addr
        if LibC:bind desc (addr_of addr) 16 < 0 then return Error "couldn't bind socket"

        Ok $ Socket desc addr

    close :: Socket -> ()
    close (Socket desc _) =
        LibC:close desc
        ()

    listen :: Socket -> Int32 -> Result Str ()
    listen (Socket desc _) max_buffer =
        if LibC:listen desc max_buffer < 0 
        then Error "error while listening"
        else Ok ()

    accept :: Socket -> Result Str Socket
    accept (Socket desc _) =
        let size = 16 :: LibC:SocklenT
        let addr = Intrinsics:unsafe (Intrinsics:zeroed (Proxy :: Proxy LibC:SockAddr))
        let sock = LibC:accept desc (addr_of addr) (addr_of size)

        if sock < 0
        then Error "error accepting connection"
        else Ok $ Socket sock addr

    receive :: Socket -> Slice Byte -> Result Str Int
    receive (Socket desc _) buffer =
        let buffer_addr, buffer_len = Intrinsics:unsafe (Intrinsics:transmute buffer)
        let bytes_received = LibC:recv desc buffer_addr buffer_len 0

        if bytes_received < 0
        then Error "error receiving"
        else Ok $ Intrinsics:iconvert bytes_received

    send :: Socket -> Slice Byte -> Result Str ()
    send (Socket desc _) buffer =
        let buffer_addr, buffer_len = Intrinsics:unsafe (Intrinsics:transmute buffer)

        if LibC:send desc buffer_addr buffer_len 0 < 0
        then Error "error sending"
        else Ok ()


module Net =
    type IpAddr =
        | V4 Ipv4Addr
        | V6 Ipv6Addr

    type Ipv4Addr = | Ipv4Addr (Array 4 Byte)
    type Ipv6Addr = | Ipv6Addr (Array 16 Byte)

module Net:Ipv4Addr =
    import Net
    
    const UNSPECIFIED = Ipv4Addr [0, 0, 0, 0]
    const LOCALHOST = Ipv4Addr [127, 0, 0, 1]
    const BROADCAST = Ipv4Addr [255, 255, 255, 255]

module Net:Ipv6Addr =
    import Net
    
    const UNSPECIFIED = Ipv6Addr [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    const LOCALHOST = Ipv6Addr [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
