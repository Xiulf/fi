module Test =

import Core
import Socket (Socket, listen, accept, receive, send, close)

@main
main :: Result Str ()
main = try
    socket <- Socket:new_ipv4 (LibC:NetAddr 127 0 0 1) 8080
    socket .listen 1
    let _ = println "listening for incoming connections"
    client <- socket .accept
    let _ = println "client connected"
    let buffer = Data:Array:zeroed :: Array 1000 Byte
    let slice = Data:Array:as_slice buffer
    received <- client .receive slice
    client .send (slice # (0..received))
    let _ = client .close
    let _ = socket .close
    ret ()


println :: Str -> ()
println s =
    let ptr, _ = Intrinsics:unsafe (Intrinsics:transmute s) :: _, Uint
    LibC:puts ptr
    ()


member (Result Str ()) of Termination =
    report (Ok _) = ExitCode 0
    report (Error e) =
        println e
        ExitCode -1


module TcpListener =
    import Core
    import Socket (Socket)
    
    type TcpListener = | TcpListener Socket

    bind :: LibC:NetAddr -> Uint16 -> Result Str TcpListener
    bind addr port = try
        socket <- Socket:new_ipv4 addr port
        ret $ TcpListener socket

    close :: TcpListener -> ()
    close (TcpListener socket) = Socket:close socket


module Socket (module Socket, module C) =
    import Core
    import LibC (NetAddr)
    import LibC (NetAddr) as C
    import Intrinsics (addr_of)
    
    type Socket =
        | Socket LibC:C_Int LibC:SockAddr

    new_ipv4 :: NetAddr -> Uint16 -> Result Str Socket
    new_ipv4 addr port =
        let desc = LibC:socket LibC:AF_INET LibC:SOCK_STREAM 0
        if desc < 0 then return Error "error while creating socket"

        let family = Intrinsics:iconvert LibC:AF_INET
        let port = Data:Int:to_be port
        let addr = LibC:SockAddr family port addr
        if LibC:bind desc (addr_of addr) 16 < 0 then return Error "couldn't bind socket"

        Ok $ Socket desc addr

    close :: Socket -> ()
    close (Socket desc _) =
        LibC:close desc
        ()

    listen :: Socket -> Int32 -> Result Str ()
    listen (Socket desc _) max_buffer =
        if LibC:listen desc max_buffer < 0 
        then Error "error while listening"
        else Ok ()

    accept :: Socket -> Result Str Socket
    accept (Socket desc _) =
        let size = 16 :: LibC:SocklenT
        let addr = Intrinsics:unsafe (Intrinsics:zeroed (Proxy :: Proxy LibC:SockAddr))
        let sock = LibC:accept desc (addr_of addr) (addr_of size)

        if sock < 0
        then Error "error accepting connection"
        else Ok $ Socket sock addr

    receive :: Socket -> Slice Byte -> Result Str Int
    receive (Socket desc _) buffer =
        let buffer_addr, buffer_len = Intrinsics:unsafe (Intrinsics:transmute buffer)
        let bytes_received = LibC:recv desc buffer_addr buffer_len 0

        if bytes_received < 0
        then Error "error receiving"
        else Ok $ Intrinsics:iconvert bytes_received

    send :: Socket -> Slice Byte -> Result Str ()
    send (Socket desc _) buffer =
        let buffer_addr, buffer_len = Intrinsics:unsafe (Intrinsics:transmute buffer)

        if LibC:send desc buffer_addr buffer_len 0 < 0
        then Error "error sending"
        else Ok ()


module Net =
    type IpAddr =
        | V4 Ipv4Addr
        | V6 Ipv6Addr

    type Ipv4Addr = | Ipv4Addr (Array 4 Byte)
    type Ipv6Addr = | Ipv6Addr (Array 16 Byte)

module Net:Ipv4Addr =
    import Net
    
    const UNSPECIFIED = Ipv4Addr [0, 0, 0, 0]
    const LOCALHOST = Ipv4Addr [127, 0, 0, 1]
    const BROADCAST = Ipv4Addr [255, 255, 255, 255]

module Net:Ipv6Addr =
    import Net
    
    const UNSPECIFIED = Ipv6Addr [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    const LOCALHOST = Ipv6Addr [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
