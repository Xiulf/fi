module Core.Vec

import Core.Ptr (NULL)
import Libc (memcpy, malloc, free, realloc)

struct Vec<T>
    ptr: *T
    cap: usize
    len: usize
end

@poly
fn new<T>() -> Vec<T>
    var ptr = NULL;
    var cap = if `T`.size == 0; !0 else 0 end;

    Vec(ptr, cap, 0)
end

@poly
fn push<T>(self: *Vec<T>, item: T)
    reserve(self, 1);

    var ptr = self.*.ptr + self.*.len * `T`.stride;

    memcpy(ptr.(*()), item.(*()), `T`.size);
    self.*.len += 1;
end

@poly
fn index<T>(self: *Vec<T>, idx: usize) -> *T
    var ptr = self.*.ptr + idx * `T`.stride;

    ptr.(*T)
end

@poly
fn reserve<T>(self: *Vec<T>, n: usize)
    if self.*.ptr == NULL
        self.*.ptr = malloc(`T`.stride).(*T);
        self.*.cap += 1;
    end

    while self.*.len + n > self.*.cap
        self.*.cap *= 2;
        self.*.ptr = realloc(self.*.ptr.(*()), self.*.cap * `T`.stride).(*T);
    end
end

@poly
fn drop<T>(self: *Vec<T>)
    free(self.*.ptr.(*()));
    self.*.ptr = NULL;
end
